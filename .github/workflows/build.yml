name: Build and Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  python-build:
    strategy:
      matrix:
        python-version: ["3.11"]
        os: [ubuntu-latest, macos-latest, windows-latest]
      fail-fast: false
    
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'
    
    - name: Copy README.md to core directory
      run: |
        cp README.md core/
        cp README.md core/log2ml/
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        cd core
        pip install -e ".[dev]"
        cd ..
    
    - name: Test with pytest
      run: |
        cd core
        pytest tests/ --cov=log2ml --cov-report=xml
        cd ..
    
    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./core/coverage.xml
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  tauri-build:
    needs: python-build
    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-latest, windows-latest]

    runs-on: ${{ matrix.platform }}
    steps:
    - uses: actions/checkout@v4

    - name: Check GUI directory (Windows)
      id: check_gui
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        if ((Test-Path 'gui/vector-analyzer') -and (Test-Path 'gui/vector-analyzer/package.json')) {
          "gui_exists=true" >> $env:GITHUB_OUTPUT
        } else {
          "gui_exists=false" >> $env:GITHUB_OUTPUT
          Write-Host "GUI directory or package.json not found - skipping Tauri build"
          exit 0
        }

    - name: Check GUI directory (Unix)
      id: check_gui_unix
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: |
        if [ -d "gui/vector-analyzer" ] && [ -f "gui/vector-analyzer/package.json" ]; then
          echo "gui_exists=true" >> $GITHUB_OUTPUT
        else
          echo "gui_exists=false" >> $GITHUB_OUTPUT
          echo "GUI directory or package.json not found - skipping Tauri build"
          exit 0
        fi

    - name: Setup node
      if: |
        (runner.os == 'Windows' && steps.check_gui.outputs.gui_exists == 'true') ||
        (runner.os != 'Windows' && steps.check_gui_unix.outputs.gui_exists == 'true')
      uses: actions/setup-node@v4
      with:
        node-version: 20

    - name: Install Rust stable
      if: |
        (runner.os == 'Windows' && steps.check_gui.outputs.gui_exists == 'true') ||
        (runner.os != 'Windows' && steps.check_gui_unix.outputs.gui_exists == 'true')
      uses: dtolnay/rust-toolchain@stable
      with:
        components: clippy

    - name: Rust lint
      if: |
        (runner.os == 'Windows' && steps.check_gui.outputs.gui_exists == 'true') ||
        (runner.os != 'Windows' && steps.check_gui_unix.outputs.gui_exists == 'true')
      run: |
        cd gui/vector-analyzer/src-tauri
        cargo fmt --check
        cargo clippy -- -D warnings

    - name: Install dependencies (ubuntu only)
      if: ${{ steps.check_gui_unix.outputs.gui_exists == 'true' && matrix.platform == 'ubuntu-latest' }}
      run: |
        # Add required repositories
        sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test
        sudo apt-get update

        # Install required packages
        sudo apt-get install -y \
          libgtk-3-dev \
          libwebkit2gtk-4.0-dev \
          libappindicator3-dev \
          librsvg2-dev \
          patchelf \
          libatk1.0-dev \
          libgdk-pixbuf2.0-dev \
          libcairo2-dev \
          libsoup2.4-dev \
          libpango1.0-dev \
          build-essential \
          curl \
          wget \
          file \
          libssl-dev \
          pkg-config \
          gtk+3.0 \
          gir1.2-gtk-3.0 \
          libatk-bridge2.0-dev \
          at-spi2-core \
          libatk-adaptor \
          libglib2.0-dev \
          libgtk-3-0 \
          libgtk-3-common \
          libgtk-3-bin \
          libgdk3.0-cil \
          libgdk3.0-cil-dev

    - name: Configure pkg-config and environment (ubuntu only)
      if: ${{ steps.check_gui_unix.outputs.gui_exists == 'true' && matrix.platform == 'ubuntu-latest' }}
      run: |
        # Find pkg-config files
        echo "Finding pkg-config files..."
        PKG_CONFIG_FILES=$(find /usr -name "*.pc" 2>/dev/null || true)
        
        # Extract unique directories containing .pc files
        PKG_CONFIG_PATHS=$(echo "$PKG_CONFIG_FILES" | xargs -I {} dirname {} | sort -u | tr '\n' ':')
        
        # Set environment variables
        echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATHS" >> $GITHUB_ENV
        echo "PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1" >> $GITHUB_ENV
        echo "PKG_CONFIG_ALLOW_SYSTEM_LIBS=1" >> $GITHUB_ENV
        
        # Export for current shell
        export PKG_CONFIG_PATH="$PKG_CONFIG_PATHS"
        export PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1
        export PKG_CONFIG_ALLOW_SYSTEM_LIBS=1
        
        # Debug information
        echo "PKG_CONFIG_PATH directories:"
        echo "$PKG_CONFIG_PATHS" | tr ':' '\n'
        
        echo "Checking for specific .pc files:"
        for pc in atk gdk-3.0 gtk+-3.0; do
          echo "Looking for $pc.pc..."
          find /usr -name "$pc.pc" 2>/dev/null || echo "$pc.pc not found"
          if pkg-config --exists $pc; then
            echo "$pc found by pkg-config"
            echo "Version: $(pkg-config --modversion $pc)"
            echo "Cflags: $(pkg-config --cflags $pc)"
            echo "Libs: $(pkg-config --libs $pc)"
          else
            echo "$pc not found by pkg-config"
          fi
        done
        
        # Create symbolic links if needed
        for dir in /usr/lib/x86_64-linux-gnu/pkgconfig /usr/share/pkgconfig; do
          sudo mkdir -p $dir
          if [ -f /usr/lib/x86_64-linux-gnu/pkgconfig/atk.pc ] && [ ! -f $dir/atk.pc ]; then
            sudo ln -s /usr/lib/x86_64-linux-gnu/pkgconfig/atk.pc $dir/atk.pc
          fi
          if [ -f /usr/lib/x86_64-linux-gnu/pkgconfig/gdk-3.0.pc ] && [ ! -f $dir/gdk-3.0.pc ]; then
            sudo ln -s /usr/lib/x86_64-linux-gnu/pkgconfig/gdk-3.0.pc $dir/gdk-3.0.pc
          fi
        done
        
        echo "System package status:"
        dpkg -l | grep -E 'libgtk|libgdk|libatk|gtk|gdk|atk'

    - name: Verify package configuration
      if: ${{ steps.check_gui_unix.outputs.gui_exists == 'true' && matrix.platform == 'ubuntu-latest' }}
      run: |
        echo "Testing pkg-config with required packages..."
        pkg-config --cflags --libs atk || echo "atk pkg-config failed"
        pkg-config --cflags --libs gdk-3.0 || echo "gdk-3.0 pkg-config failed"
        pkg-config --cflags --libs gtk+-3.0 || echo "gtk+-3.0 pkg-config failed"
        
        echo "Library locations:"
        ldconfig -p | grep -E 'libgtk|libgdk|libatk'

    - name: Create valid icon for Windows
      if: ${{ steps.check_gui.outputs.gui_exists == 'true' && matrix.platform == 'windows-latest' }}
      shell: pwsh
      run: |
        # Create a directory for the icon if it doesn't exist
        $iconDir = "gui/vector-analyzer/src-tauri/icons"
        New-Item -ItemType Directory -Force -Path $iconDir

        # Create a minimal valid 16x16 ICO file (smallest possible valid ICO)
        $icoBytes = @(
          # ICO Header (6 bytes)
          0x00, 0x00,  # Reserved (0)
          0x01, 0x00,  # Type (1 = ICO)
          0x01, 0x00,  # Number of images (1)

          # Image Directory Entry (16 bytes)
          0x10, 0x00,  # Width (16 pixels)
          0x10, 0x00,  # Height (16 pixels)
          0x00,        # Color palette (0 = no palette)
          0x00,        # Reserved (0)
          0x01, 0x00,  # Color planes (1)
          0x01, 0x00,  # Bits per pixel (1)
          0x28, 0x01, 0x00, 0x00,  # Size of image data (296 bytes)
          0x16, 0x00, 0x00, 0x00,  # Offset to image data (22 bytes)

          # DIB Header (40 bytes)
          0x28, 0x00, 0x00, 0x00,  # Header size (40 bytes)
          0x10, 0x00, 0x00, 0x00,  # Width (16 pixels)
          0x20, 0x00, 0x00, 0x00,  # Height (32 pixels = 16 * 2 for XOR and AND masks)
          0x01, 0x00,              # Planes (1)
          0x01, 0x00,              # Bits per pixel (1)
          0x00, 0x00, 0x00, 0x00,  # Compression (0 = none)
          0x00, 0x00, 0x00, 0x00,  # Image size (0 for uncompressed)
          0x00, 0x00, 0x00, 0x00,  # X pixels per meter (0)
          0x00, 0x00, 0x00, 0x00,  # Y pixels per meter (0)
          0x02, 0x00, 0x00, 0x00,  # Colors used (2)
          0x02, 0x00, 0x00, 0x00   # Important colors (2)
        )

        # Color table (8 bytes)
        $colorTable = @(
          0x00, 0x00, 0x00, 0x00,  # Color 0 (black)
          0xFF, 0xFF, 0xFF, 0x00   # Color 1 (white)
        )

        # XOR mask (32 bytes, 16x16 pixels, 1 bit per pixel, padded to 32-bit boundary)
        $xorMask = @(
          0xFF, 0xFF,  # Row 1-8 (all white)
          0xFF, 0xFF,  # Row 9-16 (all white)
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF,
          0xFF, 0xFF
        )

        # AND mask (32 bytes, 16x16 pixels, 1 bit per pixel, padded to 32-bit boundary)
        $andMask = @(
          0x00, 0x00,  # Row 1-8 (all transparent)
          0x00, 0x00,  # Row 9-16 (all transparent)
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00,
          0x00, 0x00
        )

        # Combine all parts
        $iconData = $icoBytes + $colorTable + $xorMask + $andMask

        # Write the icon file
        [System.IO.File]::WriteAllBytes("$iconDir/icon.ico", $iconData)

        # Verify the file
        $fileInfo = Get-Item "$iconDir/icon.ico"
        if ($fileInfo.Exists) {
            Write-Host "Icon file created successfully"
            Write-Host "File size: $($fileInfo.Length) bytes"
            Write-Host "File path: $($fileInfo.FullName)"
            
            # Read and display first few bytes to verify header
            $bytes = [System.IO.File]::ReadAllBytes("$iconDir/icon.ico")
            Write-Host "First 22 bytes (header + directory entry):"
            for ($i = 0; $i -lt [Math]::Min(22, $bytes.Length); $i++) {
                Write-Host ("{0:X2} " -f $bytes[$i]) -NoNewline
            }
            Write-Host ""
        } else {
            Write-Error "Failed to create icon file"
            exit 1
        }

    - name: Install dependencies (macos only)
      if: ${{ steps.check_gui_unix.outputs.gui_exists == 'true' && matrix.platform == 'macos-latest' }}
      run: |
        brew install pkg-config

    - name: Install frontend dependencies
      if: |
        (runner.os == 'Windows' && steps.check_gui.outputs.gui_exists == 'true') ||
        (runner.os != 'Windows' && steps.check_gui_unix.outputs.gui_exists == 'true')
      run: |
        cd gui/vector-analyzer
        yarn install

    - name: Build Tauri app
      if: |
        (runner.os == 'Windows' && steps.check_gui.outputs.gui_exists == 'true') ||
        (runner.os != 'Windows' && steps.check_gui_unix.outputs.gui_exists == 'true')
      run: |
        cd gui/vector-analyzer
        yarn run tauri:build
